{"ast":null,"code":"'use strict';\n\nvar invariant = require('invariant');\n\nvar TRACE_TAG_REACT_APPS = 1 << 17;\nvar TRACE_TAG_JS_VM_CALLS = 1 << 27;\nvar _enabled = false;\nvar _asyncCookie = 0;\nvar _markStack = [];\n\nvar _markStackIndex = -1;\n\nvar _canInstallReactHook = false;\nvar REACT_MARKER = \"\\u269B\";\nvar userTimingPolyfill = __DEV__ ? {\n  mark: function mark(markName) {\n    if (_enabled) {\n      _markStackIndex++;\n      _markStack[_markStackIndex] = markName;\n      var systraceLabel = markName;\n\n      if (markName[0] === REACT_MARKER) {\n        var indexOfId = markName.lastIndexOf(' (#');\n        var cutoffIndex = indexOfId !== -1 ? indexOfId : markName.length;\n        systraceLabel = markName.slice(2, cutoffIndex);\n      }\n\n      Systrace.beginEvent(systraceLabel);\n    }\n  },\n  measure: function measure(measureName, startMark, endMark) {\n    if (_enabled) {\n      invariant(typeof measureName === 'string' && typeof startMark === 'string' && typeof endMark === 'undefined', 'Only performance.measure(string, string) overload is supported.');\n      var topMark = _markStack[_markStackIndex];\n      invariant(startMark === topMark, 'There was a mismatching performance.measure() call. ' + 'Expected \"%s\" but got \"%s.\"', topMark, startMark);\n      _markStackIndex--;\n      Systrace.endEvent();\n    }\n  },\n  clearMarks: function clearMarks(markName) {\n    if (_enabled) {\n      if (_markStackIndex === -1) {\n        return;\n      }\n\n      if (markName === _markStack[_markStackIndex]) {\n        if (userTimingPolyfill != null) {\n          userTimingPolyfill.measure(markName, markName);\n        }\n      }\n    }\n  },\n  clearMeasures: function clearMeasures() {}\n} : null;\n\nfunction installPerformanceHooks(polyfill) {\n  if (polyfill) {\n    if (global.performance === undefined) {\n      global.performance = {};\n    }\n\n    Object.keys(polyfill).forEach(function (methodName) {\n      if (typeof global.performance[methodName] !== 'function') {\n        global.performance[methodName] = polyfill[methodName];\n      }\n    });\n  }\n}\n\nvar Systrace = {\n  installReactHook: function installReactHook() {\n    if (_enabled) {\n      if (__DEV__) {\n        installPerformanceHooks(userTimingPolyfill);\n      }\n    }\n\n    _canInstallReactHook = true;\n  },\n  setEnabled: function setEnabled(enabled) {\n    if (_enabled !== enabled) {\n      if (__DEV__) {\n        if (enabled) {\n          global.nativeTraceBeginLegacy && global.nativeTraceBeginLegacy(TRACE_TAG_JS_VM_CALLS);\n        } else {\n          global.nativeTraceEndLegacy && global.nativeTraceEndLegacy(TRACE_TAG_JS_VM_CALLS);\n        }\n\n        if (_canInstallReactHook) {\n          if (enabled) {\n            installPerformanceHooks(userTimingPolyfill);\n          }\n        }\n      }\n\n      _enabled = enabled;\n    }\n  },\n  isEnabled: function isEnabled() {\n    return _enabled;\n  },\n  beginEvent: function beginEvent(profileName, args) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceBeginSection(TRACE_TAG_REACT_APPS, profileName, args);\n    }\n  },\n  endEvent: function endEvent() {\n    if (_enabled) {\n      global.nativeTraceEndSection(TRACE_TAG_REACT_APPS);\n    }\n  },\n  beginAsyncEvent: function beginAsyncEvent(profileName) {\n    var cookie = _asyncCookie;\n\n    if (_enabled) {\n      _asyncCookie++;\n      profileName = typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceBeginAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie);\n    }\n\n    return cookie;\n  },\n  endAsyncEvent: function endAsyncEvent(profileName, cookie) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceEndAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie);\n    }\n  },\n  counterEvent: function counterEvent(profileName, value) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceCounter && global.nativeTraceCounter(TRACE_TAG_REACT_APPS, profileName, value);\n    }\n  }\n};\n\nif (__DEV__) {\n  require.Systrace = Systrace;\n}\n\nmodule.exports = Systrace;","map":{"version":3,"sources":["/Users/seanhaverstock/Codesmith/Embr/node_modules/react-native/Libraries/Performance/Systrace.js"],"names":["invariant","require","TRACE_TAG_REACT_APPS","TRACE_TAG_JS_VM_CALLS","_enabled","_asyncCookie","_markStack","_markStackIndex","_canInstallReactHook","REACT_MARKER","userTimingPolyfill","__DEV__","mark","markName","systraceLabel","indexOfId","lastIndexOf","cutoffIndex","length","slice","Systrace","beginEvent","measure","measureName","startMark","endMark","topMark","endEvent","clearMarks","clearMeasures","installPerformanceHooks","polyfill","global","performance","undefined","Object","keys","forEach","methodName","installReactHook","setEnabled","enabled","nativeTraceBeginLegacy","nativeTraceEndLegacy","isEnabled","profileName","args","nativeTraceBeginSection","nativeTraceEndSection","beginAsyncEvent","cookie","nativeTraceBeginAsyncSection","endAsyncEvent","nativeTraceEndAsyncSection","counterEvent","value","nativeTraceCounter","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nconst invariant = require('invariant');\n\nconst TRACE_TAG_REACT_APPS = 1 << 17; // eslint-disable-line no-bitwise\nconst TRACE_TAG_JS_VM_CALLS = 1 << 27; // eslint-disable-line no-bitwise\n\nlet _enabled = false;\nlet _asyncCookie = 0;\nconst _markStack = [];\nlet _markStackIndex = -1;\nlet _canInstallReactHook = false;\n\n// Implements a subset of User Timing API necessary for React measurements.\n// https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API\nconst REACT_MARKER = '\\u269B';\nconst userTimingPolyfill = __DEV__\n  ? {\n      mark(markName: string) {\n        if (_enabled) {\n          _markStackIndex++;\n          _markStack[_markStackIndex] = markName;\n          let systraceLabel = markName;\n          // Since perf measurements are a shared namespace in User Timing API,\n          // we prefix all React results with a React emoji.\n          if (markName[0] === REACT_MARKER) {\n            // This is coming from React.\n            // Removing component IDs keeps trace colors stable.\n            const indexOfId = markName.lastIndexOf(' (#');\n            const cutoffIndex = indexOfId !== -1 ? indexOfId : markName.length;\n            // Also cut off the emoji because it breaks Systrace\n            systraceLabel = markName.slice(2, cutoffIndex);\n          }\n          Systrace.beginEvent(systraceLabel);\n        }\n      },\n      measure(measureName: string, startMark: ?string, endMark: ?string) {\n        if (_enabled) {\n          invariant(\n            typeof measureName === 'string' &&\n              typeof startMark === 'string' &&\n              typeof endMark === 'undefined',\n            'Only performance.measure(string, string) overload is supported.',\n          );\n          const topMark = _markStack[_markStackIndex];\n          invariant(\n            startMark === topMark,\n            'There was a mismatching performance.measure() call. ' +\n              'Expected \"%s\" but got \"%s.\"',\n            topMark,\n            startMark,\n          );\n          _markStackIndex--;\n          // We can't use more descriptive measureName because Systrace doesn't\n          // let us edit labels post factum.\n          Systrace.endEvent();\n        }\n      },\n      clearMarks(markName: string) {\n        if (_enabled) {\n          if (_markStackIndex === -1) {\n            return;\n          }\n          if (markName === _markStack[_markStackIndex]) {\n            // React uses this for \"cancelling\" started measurements.\n            // Systrace doesn't support deleting measurements, so we just stop them.\n            if (userTimingPolyfill != null) {\n              userTimingPolyfill.measure(markName, markName);\n            }\n          }\n        }\n      },\n      clearMeasures() {\n        // React calls this to avoid memory leaks in browsers, but we don't keep\n        // measurements anyway.\n      },\n    }\n  : null;\n\nfunction installPerformanceHooks(polyfill) {\n  if (polyfill) {\n    if (global.performance === undefined) {\n      global.performance = {};\n    }\n\n    Object.keys(polyfill).forEach(methodName => {\n      if (typeof global.performance[methodName] !== 'function') {\n        global.performance[methodName] = polyfill[methodName];\n      }\n    });\n  }\n}\n\nconst Systrace = {\n  installReactHook() {\n    if (_enabled) {\n      if (__DEV__) {\n        installPerformanceHooks(userTimingPolyfill);\n      }\n    }\n    _canInstallReactHook = true;\n  },\n\n  setEnabled(enabled: boolean) {\n    if (_enabled !== enabled) {\n      if (__DEV__) {\n        if (enabled) {\n          global.nativeTraceBeginLegacy &&\n            global.nativeTraceBeginLegacy(TRACE_TAG_JS_VM_CALLS);\n        } else {\n          global.nativeTraceEndLegacy &&\n            global.nativeTraceEndLegacy(TRACE_TAG_JS_VM_CALLS);\n        }\n        if (_canInstallReactHook) {\n          if (enabled) {\n            installPerformanceHooks(userTimingPolyfill);\n          }\n        }\n      }\n      _enabled = enabled;\n    }\n  },\n\n  isEnabled(): boolean {\n    return _enabled;\n  },\n\n  /**\n   * beginEvent/endEvent for starting and then ending a profile within the same call stack frame\n   **/\n  beginEvent(profileName?: any, args?: any) {\n    if (_enabled) {\n      profileName =\n        typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceBeginSection(TRACE_TAG_REACT_APPS, profileName, args);\n    }\n  },\n\n  endEvent() {\n    if (_enabled) {\n      global.nativeTraceEndSection(TRACE_TAG_REACT_APPS);\n    }\n  },\n\n  /**\n   * beginAsyncEvent/endAsyncEvent for starting and then ending a profile where the end can either\n   * occur on another thread or out of the current stack frame, eg await\n   * the returned cookie variable should be used as input into the endAsyncEvent call to end the profile\n   **/\n  beginAsyncEvent(profileName?: any): any {\n    const cookie = _asyncCookie;\n    if (_enabled) {\n      _asyncCookie++;\n      profileName =\n        typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceBeginAsyncSection(\n        TRACE_TAG_REACT_APPS,\n        profileName,\n        cookie,\n      );\n    }\n    return cookie;\n  },\n\n  endAsyncEvent(profileName?: any, cookie?: any) {\n    if (_enabled) {\n      profileName =\n        typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceEndAsyncSection(\n        TRACE_TAG_REACT_APPS,\n        profileName,\n        cookie,\n      );\n    }\n  },\n\n  /**\n   * counterEvent registers the value to the profileName on the systrace timeline\n   **/\n  counterEvent(profileName?: any, value?: any) {\n    if (_enabled) {\n      profileName =\n        typeof profileName === 'function' ? profileName() : profileName;\n      global.nativeTraceCounter &&\n        global.nativeTraceCounter(TRACE_TAG_REACT_APPS, profileName, value);\n    }\n  },\n};\n\nif (__DEV__) {\n  // This is needed, because require callis in polyfills are not processed as\n  // other files. Therefore, calls to `require('moduleId')` are not replaced\n  // with numeric IDs\n  // TODO(davidaurelio) Scan polyfills for dependencies, too (t9759686)\n  (require: any).Systrace = Systrace;\n}\n\nmodule.exports = Systrace;\n"]},"metadata":{},"sourceType":"script"}