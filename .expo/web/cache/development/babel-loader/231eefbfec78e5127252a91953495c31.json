{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createStringifySafeWithLimits = createStringifySafeWithLimits;\nexports.default = void 0;\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction createStringifySafeWithLimits(limits) {\n  var _limits$maxDepth = limits.maxDepth,\n      maxDepth = _limits$maxDepth === void 0 ? Number.POSITIVE_INFINITY : _limits$maxDepth,\n      _limits$maxStringLimi = limits.maxStringLimit,\n      maxStringLimit = _limits$maxStringLimi === void 0 ? Number.POSITIVE_INFINITY : _limits$maxStringLimi,\n      _limits$maxArrayLimit = limits.maxArrayLimit,\n      maxArrayLimit = _limits$maxArrayLimit === void 0 ? Number.POSITIVE_INFINITY : _limits$maxArrayLimit,\n      _limits$maxObjectKeys = limits.maxObjectKeysLimit,\n      maxObjectKeysLimit = _limits$maxObjectKeys === void 0 ? Number.POSITIVE_INFINITY : _limits$maxObjectKeys;\n  var stack = [];\n\n  function replacer(key, value) {\n    while (stack.length && this !== stack[0]) {\n      stack.shift();\n    }\n\n    if (typeof value === 'string') {\n      var truncatedString = '...(truncated)...';\n\n      if (value.length > maxStringLimit + truncatedString.length) {\n        return value.substring(0, maxStringLimit) + truncatedString;\n      }\n\n      return value;\n    }\n\n    if (typeof value !== 'object' || value === null) {\n      return value;\n    }\n\n    var retval = value;\n\n    if (Array.isArray(value)) {\n      if (stack.length >= maxDepth) {\n        retval = \"[ ... array with \" + value.length + \" values ... ]\";\n      } else if (value.length > maxArrayLimit) {\n        retval = value.slice(0, maxArrayLimit).concat([\"... extra \" + (value.length - maxArrayLimit) + \" values truncated ...\"]);\n      }\n    } else {\n      (0, _invariant.default)(typeof value === 'object', 'This was already found earlier');\n      var keys = Object.keys(value);\n\n      if (stack.length >= maxDepth) {\n        retval = \"{ ... object with \" + keys.length + \" keys ... }\";\n      } else if (keys.length > maxObjectKeysLimit) {\n        retval = {};\n\n        for (var _iterator = _createForOfIteratorHelperLoose(keys.slice(0, maxObjectKeysLimit)), _step; !(_step = _iterator()).done;) {\n          var k = _step.value;\n          retval[k] = value[k];\n        }\n\n        var truncatedKey = '...(truncated keys)...';\n        retval[truncatedKey] = keys.length - maxObjectKeysLimit;\n      }\n    }\n\n    stack.unshift(retval);\n    return retval;\n  }\n\n  return function stringifySafe(arg) {\n    if (arg === undefined) {\n      return 'undefined';\n    } else if (arg === null) {\n      return 'null';\n    } else if (typeof arg === 'function') {\n      try {\n        return arg.toString();\n      } catch (e) {\n        return '[function unknown]';\n      }\n    } else if (arg instanceof Error) {\n      return arg.name + ': ' + arg.message;\n    } else {\n      try {\n        var ret = JSON.stringify(arg, replacer);\n\n        if (ret === undefined) {\n          return '[\"' + typeof arg + '\" failed to stringify]';\n        }\n\n        return ret;\n      } catch (e) {\n        if (typeof arg.toString === 'function') {\n          try {\n            return arg.toString();\n          } catch (E) {}\n        }\n      }\n    }\n\n    return '[\"' + typeof arg + '\" failed to stringify]';\n  };\n}\n\nvar stringifySafe = createStringifySafeWithLimits({\n  maxDepth: 10,\n  maxStringLimit: 100,\n  maxArrayLimit: 50,\n  maxObjectKeysLimit: 50\n});\nvar _default = stringifySafe;\nexports.default = _default;","map":{"version":3,"sources":["/Users/seanhaverstock/Codesmith/Embr/node_modules/react-native/Libraries/Utilities/stringifySafe.js"],"names":["createStringifySafeWithLimits","limits","maxDepth","Number","POSITIVE_INFINITY","maxStringLimit","maxArrayLimit","maxObjectKeysLimit","stack","replacer","key","value","length","shift","truncatedString","substring","retval","Array","isArray","slice","concat","keys","Object","k","truncatedKey","unshift","stringifySafe","arg","undefined","toString","e","Error","name","message","ret","JSON","stringify","E"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\nimport invariant from 'invariant';\n\n/**\n * Tries to stringify with JSON.stringify and toString, but catches exceptions\n * (e.g. from circular objects) and always returns a string and never throws.\n */\nexport function createStringifySafeWithLimits(limits: {|\n  maxDepth?: number,\n  maxStringLimit?: number,\n  maxArrayLimit?: number,\n  maxObjectKeysLimit?: number,\n|}): mixed => string {\n  const {\n    maxDepth = Number.POSITIVE_INFINITY,\n    maxStringLimit = Number.POSITIVE_INFINITY,\n    maxArrayLimit = Number.POSITIVE_INFINITY,\n    maxObjectKeysLimit = Number.POSITIVE_INFINITY,\n  } = limits;\n  const stack = [];\n  function replacer(key: string, value: mixed): mixed {\n    while (stack.length && this !== stack[0]) {\n      stack.shift();\n    }\n\n    if (typeof value === 'string') {\n      const truncatedString = '...(truncated)...';\n      if (value.length > maxStringLimit + truncatedString.length) {\n        return value.substring(0, maxStringLimit) + truncatedString;\n      }\n      return value;\n    }\n    if (typeof value !== 'object' || value === null) {\n      return value;\n    }\n\n    let retval = value;\n    if (Array.isArray(value)) {\n      if (stack.length >= maxDepth) {\n        retval = `[ ... array with ${value.length} values ... ]`;\n      } else if (value.length > maxArrayLimit) {\n        retval = value\n          .slice(0, maxArrayLimit)\n          .concat([\n            `... extra ${value.length - maxArrayLimit} values truncated ...`,\n          ]);\n      }\n    } else {\n      // Add refinement after Array.isArray call.\n      invariant(typeof value === 'object', 'This was already found earlier');\n      let keys = Object.keys(value);\n      if (stack.length >= maxDepth) {\n        retval = `{ ... object with ${keys.length} keys ... }`;\n      } else if (keys.length > maxObjectKeysLimit) {\n        // Return a sample of the keys.\n        retval = {};\n        for (let k of keys.slice(0, maxObjectKeysLimit)) {\n          retval[k] = value[k];\n        }\n        const truncatedKey = '...(truncated keys)...';\n        retval[truncatedKey] = keys.length - maxObjectKeysLimit;\n      }\n    }\n    stack.unshift(retval);\n    return retval;\n  }\n\n  return function stringifySafe(arg: mixed): string {\n    if (arg === undefined) {\n      return 'undefined';\n    } else if (arg === null) {\n      return 'null';\n    } else if (typeof arg === 'function') {\n      try {\n        return arg.toString();\n      } catch (e) {\n        return '[function unknown]';\n      }\n    } else if (arg instanceof Error) {\n      return arg.name + ': ' + arg.message;\n    } else {\n      // Perform a try catch, just in case the object has a circular\n      // reference or stringify throws for some other reason.\n      try {\n        const ret = JSON.stringify(arg, replacer);\n        if (ret === undefined) {\n          return '[\"' + typeof arg + '\" failed to stringify]';\n        }\n        return ret;\n      } catch (e) {\n        if (typeof arg.toString === 'function') {\n          try {\n            // $FlowFixMe: toString shouldn't take any arguments in general.\n            return arg.toString();\n          } catch (E) {}\n        }\n      }\n    }\n    return '[\"' + typeof arg + '\" failed to stringify]';\n  };\n}\n\nconst stringifySafe: mixed => string = createStringifySafeWithLimits({\n  maxDepth: 10,\n  maxStringLimit: 100,\n  maxArrayLimit: 50,\n  maxObjectKeysLimit: 50,\n});\n\nexport default stringifySafe;\n"]},"metadata":{},"sourceType":"script"}